### 为什么 Golang 垃圾回收器不实现分代和紧凑 gc？

> Ian Lance Taylor 的回复:
>
> 这已经在过去讨论过了.
>
> 忽略细节, 紧凑\(compacting\) GC 的基本优点是:
>
> * 避免碎片, 以及;
> * 允许使用简单而有效的凹凸分配器\(bump allocator\).
>
> 但是, 现代的内存分配算法, 象 Go 运行时使用的基于 tcmalloc 的方案基本上没有碎片问题. 而凹凸分配器对于 Go 这样需要锁的多线程程序中的单线程程序是简单有效的. 一般来说, 这可能更多有效地使用一组每个线程缓存来分配内存, 而在这一点上你已经失去了凹凸分配器的优势. 所以我会断言, 一般来说有很多注意事项导致今天没有真正的优势为一个多线程程序使用压缩内存分配器. 我不是说使用压缩分配器有什么问题, 我只是认为它相对于非压缩的来说没有带来任何大的优势.
>
> 现在我们来考虑一下分代 GC. 分代 GC 的关键依赖于世代的假设: 分配在一个程序中的大部分值很快变得不会用到, 所以分代 GC 有一个优势就是可以花更多的时间查看最近分配的对象. 这里 Go 不同于许多垃圾收集语言, 因为许多对象是直接在程序栈\(stack\)上分配的. Go 编译器使用逃逸分析\(escape analysis\)来查找那些在编译时生命周期就已知的对象, 将它们分配到堆栈而不是垃圾收集的内存中. 所以一般来说, 在 Go 中, 与其他语言相比, 有很大比例的分代 GC 要找的很快不会用到的\(quickly-unused\)值不会分配在 GC 内存的首要位置. 所以分代 GC 能给 Go 带来的优势相对于其他语言要小.
>
> 更微妙的是, 大多数世代 GC 实现的隐藏点是减少垃圾收集带来的程序暂停的时间. 暂停期间只看最年轻的一代, 暂停时间很短. 然而, Go 使用了一个并发垃圾收集器, 并且在 Go 中程序暂停时间与年轻代或者任意代的大小无关. Go 基本上假设, 在多线程程序中, 通过在不同的核上并行运行 GC, 不是为了最小化 GC 时间去暂停导致程序运行更长的时间, 而是总体上花更多的总 CPU 时间在 GC 上.
>
> 总之, 分代 GC 可能仍然可以为 Go 带来显著的价值, 即减少并行 GC 时的工作量. 这是一个需要测试的假设. Go 当前的 GC 工作实际上正在密切关注一个相关但不同的假设: Go 程序可能倾向于按请求分配内存.[这里](https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/view)有一个描述. 这项工作正在进行中, 现实情况是否有利还有待观察.

---

### 内存泄漏

* ##### 求子字符串\(Substrings\)导致的轻微内存泄露

> Go 规范没有指定在子字符串表达式中涉及的结果字符串和基本字符串是否应共享相同的底层内存块，该内存块托管两个字符串的底层字节序列. Go 标准编译器/运行时确实会让它们共享相同的底层内存块. 这是一个很好的设计, 这既是内存也是 CPU 消耗的明智之举. 但它可能会导致内存泄漏.
>
> 例如, 调用下面的函数 f 后, 将有 1M 字节的内存泄漏\(轻微\), 直到其他地方修改了包级\(package-level\)变量 s0.
>
> ```
> var s0 string // package level variable
>
> func f(s1 string) {
>     // 假设 s1 是一个长度大于 50 的字符串.
>     s0 = s1[:50]
>     // 现在, s0 和 s1 共享相同的底层内存块.
>     // s1 现在不存活了, 但是 s0 依然存活.
>     // 尽管仅有 50 个字节在内存块中,
>     // s0 仍旧存活的事实阻止了这 1M 字节的内存块被回收.
> }
> ```
>
> 为了避免这种轻微的内存泄漏, 我们可以将子字符串转换为一个 \[\]byte 值, 然后将 \[\]byte 值转换回 string.
>
> ```
> func f(s1 string) {
>     s0 = string([]byte(s1[:50]))
> }
> ```
>
> 我们可以使用 Go 标准编译器进行的 [一种优化](https://go101.org/article/string.html#conversion-optimizations) 来避免一次复制, 并且伴随着浪费一个字节的小的额外成本.
>
> ```
> func f(s1 string) {
>     s0 = (" " + s1[:50])[1:]
> }
> ```
>
> 上述方法的缺点是编译器优化可能会在以后失效，并且优化可能不适用于其他编译器.
>
> 避免类型内存泄漏的第三种方法是使用直到 Go 1.10 才开始支持的 strings.Builder
>
> ```
> import "strings"
>
> func f(s1 string) {
>     var b strings.Builder
>     b.Grow(50)
>     b.WriteString(s1[:50])
>     s0 = b.String()
>     // b.Reset() // 如果 b 在其他地方会用到, 那么它必须在这里重置掉.
> }
> ```

* ##### 求子切片\(Subslices\)导致的轻微内存泄露\(同上\)

> 与求子串类似, 求子切片也可能导致轻微的内存泄漏. 在下面的代码中, 调用 g 函数后, 承载 s1 元素的内存块占用的大部分内存将会丢失\(如果没有更多值引用内存块\).
>
> ```
> var s0 []int
>
> func g(s1 []int) {
>     // 假设 s1 的长度远远大于 30.
>     s0 = s1[len(s1)-30:]
> }
> ```
>
> 如果我们想避免这种轻微的内存泄漏, 我们必须复制 s0 的 30 个元素, 以便 s0 的存活不会阻止 s1 元素的内存块被回收.
>
> ```
>  func g(s1 []int) {
>     s0 = append([]int(nil), s1[len(s1)-30:]...)
> }
> ```

* ##### 不存活切片元素未重置指针导致的轻微内存泄露

> 在下面的代码中, 调用 g 函数之后, 分配给切片 s 的第一个元素的内存块会丢失. 如果最后一个元素以后从未用作任何切片的元素, 则为最后一个元素分配的内存块也会丢失.
>
> ```
> func g() []*int {
>     s := []*int{new(int), new(int), new(int), new(int)}
>     return s[1:3]
> }
> ```
>
> 如果返回的切片仍然存活, 那么它将阻止收集 s 的元素的底层内存块, 从而防止从 s 的第一个元素到最后一个元素分配的两个内存块被收集, 尽管两个元素已经不存活了.
>
> 如果我们想避免这种轻微内存泄漏, 我们必须重置不存活元素中的指针\(这里, 在函数 h 被调用后, 第一个和最后一个元素被视为不存活元素\).
>
> ```
> func h() []*int {
>     s := []*int{new(int), new(int), new(int), new(int)}
>     s1 := s[1:3]
>     s[0] = nil; s[len(s)-1] = nil
>     return s1
> }
> ```
>
> 我们经常需要重置[切片元素删除操作](https://go101.org/article/container.html#slice-manipulations)中不存活元素的指针.

* ##### 迷失的 Goroutines 导致的内存泄露

> 有时, 对于代码设计中的一些逻辑失误, 一个或多个 goroutine 会永远处于阻塞状态, 这将导致这些 goroutine 中使用的许多代码块永远无法进行垃圾收集. 这是真正的内存泄漏.
>
> 例如, 如果将以下函数作为 goroutine 的启动函数并将一个 nil channel 参数传递给它, 则 goroutine 将永远阻塞. Go 运行时认为 goroutine 仍然存活, 所以为 s 分配的内存块将永远不会被收集.
>
> ```
> func k(c <-chan bool) {
>     s := make([]int64, 1e6)
>     if <-c { // 如果 c 为 nil, 这里将永远阻塞
>         _ = s
>         // 使用 s, ...
>     }
> }
> ```
>
> 我们应该避免这种逻辑失误.

* ##### 终结器\(Finalizers\)

> 为循环引用组内的成员设置 finalizer[可能会阻止为这个循环引用组分配的所有内存块被收集](https://golang.org/pkg/runtime/#SetFinalizer). 这不是轻微而是真正的内存泄露.
>
> 在下列函数被调用并退出之后, 为 x 和 y 分配的内存块不保证在未来会被垃圾收集器回收.
>
> ```
> func memoryLeaking() {
>     type T struct {
>         v [1<<20]int
>         t *T
>     }
>
>     var finalizer = func(t *T) {
>          fmt.Println("finalizer called")
>     }
>     
>     var x, y T
>     
>     // SetFinalizer 会使 x 逃逸到堆上.
>     runtime.SetFinalizer(&x, finalizer)
>     
>     // 以下语句将导致 x 和 y 变得无法收集.
>     x.t, y.t = &y, &x // y 也逃逸到了 堆上.
> }
> ```

* ##### Go语言的GC机制可以把它的内存占用看成三个层次

> 1. `heap_in_use`是程序实际需要用到的内存的量，这部分是被引用到的，即使GC之后也无法释放。
>
> 2. GC管理的内存，GC管理的内存达到上次实际使用内存量的两倍（可配置），会触发GC操作，比如当前`heap_in_use`
>
>    是512M，那么当内存涨到1G的时候触发GC，经过回收之后的内存也许是300M，那么再次触发的时机就是内存使用量涨到600M的时候
>
> 3. 内存分配器管理的部分。向操作系统按页级别地申请大块内存，再给GC的分配使用。当GC回收之后，只是归还到分配池里面，还不会立刻归还给操作系统



